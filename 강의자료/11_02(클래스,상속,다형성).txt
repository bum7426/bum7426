클래스 : 데이터의 기능을 하나의 자료형으로 구현할 수 있는 문법

객체지향프로그래밍
 - 모든 데이터를 객체로 취급하여 그 스스로만으로도 동작하고,
 - 다른 객체의 부품으로도 사용할 수 있도록 프로그래밍 하는 방식

객체
 - 클래스로 생성된 변수

생성자
- 객체가 생성된 *직후 자동으로 호출되는 메서드
- 반환타입이 없음. 메서드오버로딩 가능
- 정의하지 않을 경우 기본 생성자 제공
- 생성시 매개변수를 넣을 수 있음.

소멸자
- 객체가 소멸되기 직전 호출되는 메서드
- ~클래스명(), 메서드 오버로딩 X
- 정의하지 않을 경우 기본 소멸자 제공

* 한정자 *
public        : 클래스 내/외부 *접근 가능
protected     : 파생클래스에서 *접근 가능
private       : 내부만 *접근 가능	 
internal
protected internal (어셈블리어)

파생클래스 or 자식클래스 or 서브클래스...
	다른 클래스를 상속받은 클래스

- 상속 ? 
	기존의 클래스로 새로운 클래스를 생성하는 문법 (튜닝)

- 기존의 클래스 : 기반클래스, 부모클래스, 슈퍼클래스

- 상속의 특징
	부모클래스의 모든 재원을 얻는다. (쓸수있다고 하지 않음)


┏부모클래스┓	 두개 다 통틀어서 자식이라고 부름
┗자식클래스┛

생성자의 호출 순서 : 부모 -> 자식
소멸자의 호출 순서 : 자식 -> 부모


1. 형 변환	as	변수 as 타입; 실패시 Null;
2. 형 확인	is

★부모 클래스 변수에 자식 클래스의 주소를 대입할 수 있다.
얻는 효과 : 관리의 편리.

* 매서드 오버로딩
-> 반환타입에 관계 없이 
   메서드명이 같고 매개변수가 다른 메서드 정의법
-> 같은 메서드명으로 정의할 수 있지만
   같은 프로토 타입으론 정의할 수 없다
  **   궁극적으로 호출형태가 다른 메서드 정의법 **
 //프로토 타입 -> 한정자 (반환타입) 메서드명(매개변수)

***클래스의 다형성 ( 상속을 배우는 이유 ) : 유지보수의 월등함
각각의 개성있는 것들을 하나의 자료형으로 관리하고 싶은 것
같은 부모를 상속받은 클래스는 "부모의 클래스 변수"에 자식의 클래스의 변수를 대입할 수 있다. 하지만 부모는 자식것을 기억할 수 없음(하지만 형변환을 사용할 수 있지만)하면 의미가 퇴색됨. 하지만 부모것을 호출하면 자식것을 나타내고 싶음. 관리의 편의를 위해 부모로 묶어놧지만 자식것을 나타내고 싶음...... 클래스는 일반 변수가 아닌 포인터형으로 선언됨(C++)
 처음에 골격을 잡기가 어려움..........

다형성의 기본원칙은 부모 클래스 변수(스택)
다른 자식 객체의 주소값을 대입하여, 다른 기능을 수행하는 방법

**해결
1. 부모한테 써야함 (한정자와 반환타입 사이)
-> 너 메서드 호출할 때 이게 니껀지 아닌지 확인해라는 의미
public (virtual) void .... virtual을 넣어야함.
진짜 누구껀지 확인해라. 자식이 들어가있으면 자식꺼 호출
되던 안되던 확인만 해보라는 의미. 그래서 부모꺼에 써놓음


2. 자식꺼에는 숨기는거라고 하지말고 
public (override) void 를 써라. override ->재정의

*메서드 오버라이딩
	클래스의 상속관계에서 자식 클래스에서 
	부모의 클래스를 재정의하는 문법
	속은 다를지언정 겉의 문법은 같음
	프로토타입은 같고 기능은 다르게 재정의


메모리 영역 / code  / data /  / bss /    / heap / stack /
		    전역변수 전역변수    동적할당 지역변수

new를 선언해서 사용하는 것은 heap에 할당됨.(동적할당)
int처럼 그냥 선언하면 stack에 할당.

후입선출의 자료관리 구조를 그대로 사용하고 있어서 스택이라고 부를뿐.